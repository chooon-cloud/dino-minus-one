<!DOCTYPE html>
<html>
<head>
    <script src="phaser.min.js"></script>
    <script src="rexshakepositionplugin.min.js"></script>
    <script src="ndwfc-master/ndwfc.js"></script>
    <script src="ndwfc-master/ndwfc-tools.js"></script>
    <script src="Victim.js"></script>
</head>
<body>

    <script>

    var tileIsRoad = function(index){
        let boolean1 = (index > 109 && index < 111);
        let boolean2 = (index > 126 && index < 129);
        let boolean3 = (index > 144 && index < 147);
        let boolean4 = (index > 162 && index < 165);

        return (boolean1 || boolean2 || boolean3 || boolean4);
    }

    var adjustDinoSize = function() {
        player.setScale(dinoScale);
        playerHitbox.setScale(dinoScale);
    }

    var myMap;
    var player;
    var playerHitbox;
    var dinoScale = 0.25;
    var cursors;
    var gameOver = false;
    var buildings = [];
    var people;
    var buildingGroup;
    var myWfc;
    var myWfcSize = 4;
    var supertiles =
    [
        [
            [0,144,0,0,0,0,144,0],
            [110,146,110,110,110,110,146,110],
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0],
            [110,146,110,110,110,110,146,110],
            [0,144,0,0,0,0,144,0]
        ], // supertile #0
        [
            [0,0,0,0,0,0,0,0],
            [110,110,110,110,110,110,110,110],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [110,110,110,110,110,110,110,110],
            [0,0,0,0,0,0,0,0]
        ], // supertile #1
        [
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0]
        ], // supertile #2
        [
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0],
            [0,144,18,19,19,20,144,0],
            [0,144,36,37,37,38,144,0],
            [0,144,36,37,37,38,144,0],
            [0,144,54,55,55,56,144,0],
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0]
        ], // supertile #3
        [
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,162,0],
            [0,144,0,0,0,0,0,0],
            [0,163,110,110,110,110,129,0],
            [0,0,0,0,0,0,144,0],
            [0,126,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,0,144,0]
        ], // supertile #4
        [
            [0,0,0,0,0,0,0,0],
            [110,110,110,128,110,110,110,110],
            [0,0,0,144,0,0,0,0],
            [0,0,0,144,0,0,0,0],
            [0,0,0,144,0,0,0,0],
            [0,0,0,144,0,0,0,0],
            [110,110,110,164,110,110,110,110],
            [0,0,0,0,0,0,0,0]
        ], // supertile #5
        [
            [0,144,0,0,0,0,144,0],
            [0,144,0,0,0,127,165,0],
            [0,144,0,0,127,165,0,0],
            [0,163,110,110,165,0,0,0],
            [0,0,0,0,0,0,0,0],
            [19,19,19,19,19,19,19,19],
            [37,37,37,37,37,37,37,37],
            [37,37,37,37,37,37,37,37]
        ], // supertile #6
        [
            [0,0,0,0,0,0,0,18],
            [0,0,0,0,0,0,0,36],
            [0,0,0,0,0,0,0,36],
            [0,0,0,0,0,0,0,36],
            [0,0,0,0,0,0,0,36],
            [19,19,19,19,19,19,19,74],
            [37,37,37,37,37,37,37,37],
            [37,37,37,37,37,37,37,37]
        ], // supertile #7
        [
            [20,0,0,0,0,0,0,0],
            [38,0,0,0,0,0,0,0],
            [38,0,0,0,0,0,0,0],
            [38,0,0,0,0,0,0,0],
            [38,0,0,0,0,0,0,0],
            [72,19,19,19,19,19,19,19],
            [37,37,37,37,37,37,37,37],
            [37,37,37,37,37,37,37,37]
        ] // supertile #8
    ];

    class Example extends Phaser.Scene
    {
        preload ()
        {
            this.load.image('city-tiles', 'tilemap_packed.png');
            this.load.image('dinoHitbox', 'dinoHitbox.png');
            this.load.spritesheet('dino', 'superpowers-asset-packs-characters/characters/prehistoric-platformer/monsters/mini-tyrannosaurus-1.png', { frameWidth: 80, frameHeight: 62 });
            this.load.spritesheet('person1','person1.png',{frameWidth: 8,frameHeight: 8});
            this.load.spritesheet('person2','person2.png',{frameWidth: 8,frameHeight: 8});
            this.load.spritesheet('person3','person3.png',{frameWidth: 8,frameHeight: 8});
            this.load.spritesheet('person4','person4.png',{frameWidth: 8,frameHeight: 8});
            this.load.image('complex', 'kenney_tiny-battle/Tiles/tile_0062.png');

            this.load.image('factory', 'kenney_tiny-battle/Tiles/tile_0065.png');

            this.load.plugin('rexshakepositionplugin', 'rexshakepositionplugin.min.js', true);
        }

        tileRules(){
            return [
                ["x", 0,0],
                ["y", 0,0],
                ["x", 0,1],
                ["x", 1,0],
                ["x", 1,1],
                ["x", 0,5],
                ["x", 5,0],
                ["x", 5,5],
                ["x", 1,5],
                ["x", 5,1],
                ["y", 1,5],
                ["y", 5,1],
                ["y", 0,2],
                ["y", 2,0],
                ["y", 0,3],
                ["y", 3,0],
                ["y", 2,3],
                ["y", 3,2],
                ["x", 2,3],
                ["x", 3,2],
                ["y", 2,4],
                ["y", 4,2],
                ["x", 2,4],
                ["x", 4,2],
                ["y", 4,3],
                ["y", 3,4],
                ["x", 4,3],
                ["x", 3,4],
                ["y", 2,2],
                ["y", 3,3],
                ["y", 4,4],
                ["y", 0,6],
                ["y", 1,6],
                ["y", 5,6],
                ["x", 6,7],
                ["y", 1,7],
                ["y", 5,7],
                ["y", 1,8],
                ["y", 5,8],
                ["x", 8,6],
            ];
        }

        tileWeights(arr){
            return [1,1,0.5,0.5,1,1,1,1,1];  
        }

        generateMap(){
            let startTIme = Math.floor(Date.now() / 1000);
            let nd = 2;
            let rules = this.tileRules();
            let weights = this.tileWeights(rules);
            // console.log(weights);

            myWfc = new WFC({ nd, rules, weights});
            //myWfc = new WFC({ nd, rules, weights, wave: { "0,0": 0} });
            //let wfc = new WFC({ nd, rules, weights});
            myWfc.expand([-myWfcSize,-myWfcSize],[myWfcSize,myWfcSize]);
            let i = 0;
            while (true){
                
                let done = myWfc.step();
                if (done){ 
                    break;
                }
                i++;
                if(i > 30) break;
            }
            //console.log(Math.floor(Date.now() / 1000) - startTIme);
            //console.log(myWfc.readout());
        }

        convertWfcReadOut(){
            let level = [];
            let row = [];
            for (let j = 0; j < (myWfcSize * 2 + 1)*8; j++){
                for(let k = 0; k < (myWfcSize * 2 + 1)*8; k++){
                    row.push(0);
                }
                level.push(row);
                row = [];
            }
            let readout = myWfc.readout();
            for (const [key, value] of Object.entries(readout)) {
                const coords = key.split(","); 
                let x = (parseInt(coords[0]) + parseInt(myWfcSize))*8;
                let y = (parseInt(coords[1]) + parseInt(myWfcSize))*8;
                
                //console.log("level["+x+","+y+"]");
                for(let l = 0; l < 8; l++){
                    for(let m = 0; m < 8; m++){
                        let x2 = parseInt(x) + parseInt(l);
                        let y2 = parseInt(y) + parseInt(m);
                        //console.log("level["+x2+","+y2 + "] is " + supertiles[value][l][m]);
                        level[x2][y2] = supertiles[value][l][m];
                    }
                }
            }
            return level;
        }

        create ()
        {
            this.generateMap();
            const level = this.convertWfcReadOut();
            console.log(level);
            // When loading from an array, make sure to specify the tileWidth and tileHeight
            myMap = this.make.tilemap({ data: level, tileWidth: 16, tileHeight: 16 });
            const tiles = myMap.addTilesetImage('city-tiles');
            const layer = myMap.createLayer(0, tiles, 0, 0);

            player = this.physics.add.sprite(this.cameras.main.centerX, this.cameras.main.centerY, 'dino');
            playerHitbox = this.physics.add.image(this.cameras.main.centerX, this.cameras.main.centerY,'dinoHitbox');
            playerHitbox.visible = false;
            this.anims.create({
                key: 'idle',
                frames: this.anims.generateFrameNumbers('dino', { start: 0, end: 6 }),
                frameRate: 10,
                repeat: -1
            });

            this.anims.create({
                key: 'right',
                frames: this.anims.generateFrameNumbers('dino', { start: 6, end: 10 }),
                frameRate: 10,
                repeat: -1
            });

            this.anims.create({
                key: 'eat',
                frames: this.anims.generateFrameNumbers('dino', { start: 11, end: 13 }),
                frameRate: 10,
            });



            this.cameras.main.setBounds(0,0,952,1052);
            this.cameras.main.startFollow(player);

            cursors = this.input.keyboard.createCursorKeys();

            this.physics.world.setBounds(0,0,1152,1152, true, true, true, true);

            player.setCollideWorldBounds(true);
            adjustDinoSize();

            //let person = this.physics.add.sprite(this.cameras.main.centerX + 32, this.cameras.main.centerY, 'person1');
             this.anims.create({
                key: 'person1Motion',
                frames: this.anims.generateFrameNumbers('person1', { start: 0, end: 2 }),
                frameRate: 10,
                repeat: -1
            });

             this.anims.create({
                key: 'person2Motion',
                frames: this.anims.generateFrameNumbers('person2', { start: 0, end: 2 }),
                frameRate: 10,
                repeat: -1
            });
             this.anims.create({
                key: 'person3Motion',
                frames: this.anims.generateFrameNumbers('person3', { start: 0, end: 2 }),
                frameRate: 10,
                repeat: -1
            });
             this.anims.create({
                key: 'person4Motion',
                frames: this.anims.generateFrameNumbers('person4', { start: 0, end: 2 }),
                frameRate: 10,
                repeat: -1
            });

		    people = this.physics.add.group({
			    classType: Victim,
			    createCallback: (go) => {
				    const personGo = go
				    personGo.body.onCollide = true
			    }
		    });

            buildingGroup = this.physics.add.group();

		    let peopleCollider = this.physics.add.collider(playerHitbox, people, function(obj1,obj2) {
                //peopleCollider.active = false;
                if(dinoScale < 1){
                    dinoScale += 0.05;
                    adjustDinoSize();
                }
                player.eating = true;
                player.anims.play('eat', true);
                obj2.visible = false;
                obj2.disableBody();
            }, undefined, this);

            // set up buildings
            myMap.forEachTile(function(tile){
                let d = Math.random();
                // if tile is grass
                if(tile.index == 0){
                    if(d < 0.3){
                        myMap.putTileAt(1, tile.x, tile.y);
                    }
                    else if(d < 0.15){
                        myMap.putTileAt(2, tile.x, tile.y);
                    }
                    
                    let left = myMap.getTileAt(tile.x - 1, tile.y);
                    let right = myMap.getTileAt(tile.x + 1, tile.y);
                    let top = myMap.getTileAt(tile.x, tile.y - 1);
                    let bottom = myMap.getTileAt(tile.x, tile.y + 1);

                    // check neighbors
                    let roadCount = 0;
                    if(left){
                        if(tileIsRoad(left.index)) roadCount += 1;
                    }
                    if(right){
                        if(tileIsRoad(right.index)) roadCount += 1;
                    }
                    if(top){
                        if(tileIsRoad(top.index)) roadCount += 1;
                    }
                    if(bottom){
                        if(tileIsRoad(bottom.index)) roadCount += 1;
                    }

                    if(roadCount > 0){
                        if (d < 0.2) {
                            buildings.push({"x":tile.x,"y":tile.y,"ref":'complex'});
                        }
                    }
                    
                }
                if(tile.index == 144){
                        let bottom = myMap.getTileAt(tile.x, tile.y + 1);
                        if(bottom.index == 0){
                            if(d < 0.2){
                                buildings.push({"x":tile.x,"y":tile.y,"ref":'factory'});
                            }
                            else {
                                myMap.putTileAt(162, tile.x, tile.y);
                            }
                        }
                }
            }, null, 0, 0, 72, 71); 
            for(let i = 0; i < buildings.length; i++) {
                let building = this.physics.add.image(buildings[i].x * 16 + 8, buildings[i].y * 16 + 8, buildings[i].ref);
                building.ref = buildings[i].ref;
                building.setPushable(false);
                building.health = 100;
                building.residents = 5;
                building.shake = this.plugins.get('rexshakepositionplugin').add(building, {
                    duration: 100,
                    axis: 'h',
                    magnitude: 2,
                    mode: 'effect'
                })
                buildingGroup.add(building);
                //tween.onComplete.add(function(sprite, tween) { sprite.kill(); }, this);
            }

            let buildingCollider = this.physics.add.collider(playerHitbox,buildingGroup, function(obj1,obj2){
                if(obj2.health > 0){
                    let axis = (obj2.body.touching.up || obj2.body.touching.down) ? 'v':'h';
                    obj2.shake.setAxisMode(axis);
                    obj2.shake.shake();
                    obj2.health -= 1;
                    let d = Math.random();
                    if(d <= 0.1 && obj2.residents > 0){
                        let personAppearance = Math.floor(Math.random() * 10) % 4 + 1; 
                        let person = people.get(obj2.x, obj2.y, 'person'+personAppearance);
                        obj2.residents -= 1;
                    }
                }
                else {
                    //buildingGroup.killAndHide(obj2);
                    obj2.visible = false;
                    obj2.disableBody();
                }
            });

            player.depth = 999;
            player.eating = false;
            player.on(Phaser.Animations.Events.ANIMATION_COMPLETE, function () {
                console.log("eat");
                player.eating = false;
            }, this);
        }

        update ()
        {
            if (gameOver)
            {
                return;
            }

            if (cursors.left.isDown)
            {
                //player.setVelocityX(-160 * dinoScale);
                player.setFlipX(true);
                if(!player.eating) player.anims.play('right', true);
                playerHitbox.setVelocityX(-160 * dinoScale);

                //console.log(player.x);
            }
            else if (cursors.right.isDown)
            {
                //player.setVelocityX(160 * dinoScale);
                player.setFlipX(false);
                if(!player.eating) player.anims.play('right', true);   
                playerHitbox.setVelocityX(160 * dinoScale);

                //console.log(player.x);
            }
            else if (cursors.down.isDown)
            {
                //player.setVelocityY(160 * dinoScale);
                if(!player.eating) player.anims.play('right', true);     
                //console.log(player.y);
                playerHitbox.setVelocityY(160 * dinoScale);
            }
            else if (cursors.up.isDown)
            {
                //player.setVelocityY(-160 * dinoScale);

                if(!player.eating) player.anims.play('right', true);
                //console.log(player.y); 
                playerHitbox.setVelocityY(-160 * dinoScale);

            }
            else {
                if(!player.eating) player.anims.play('idle', true);
                playerHitbox.setVelocityX(0);
                playerHitbox.setVelocityY(0);
            }
            player.x = playerHitbox.x;
            player.y = playerHitbox.y - 18 * dinoScale;
        }
    }

    const config = {
        type: Phaser.AUTO,
        width: 12.5 * 16,
        height: 6.25 * 16,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 },
                debug: false
            }
        },
        scene: Example,
        zoom: 4,
        autoCenter: true
    };

    const game = new Phaser.Game(config);       
    </script>
    <a href="tileInspector.html">tiles</a>
</body>
</html>